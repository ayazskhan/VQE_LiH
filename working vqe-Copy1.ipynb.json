{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import pylab\n",
    "import copy\n",
    "from qiskit import BasicAer\n",
    "from qiskit.aqua import aqua_globals, QuantumInstance\n",
    "from qiskit.aqua.algorithms import VQE, ExactEigensolver\n",
    "from qiskit.aqua.components.optimizers import COBYLA\n",
    "from qiskit.chemistry.aqua_extensions.components.initial_states import HartreeFock\n",
    "from qiskit.chemistry.aqua_extensions.components.variational_forms import UCCSD\n",
    "from qiskit.chemistry.drivers import PySCFDriver\n",
    "from qiskit.chemistry.core import Hamiltonian, QubitMappingType"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.6000000000000001, 0.7000000000000001, 0.8, 0.9, 1.0, 1.1, 1.2000000000000002, 1.3, 1.4000000000000001, 1.5, 1.6, 1.7000000000000002, 1.8, 1.9000000000000001, 2.0, 2.25, 2.5, 2.75, 3.0, 3.25, 3.5, 3.75, 4.0, 4.25, 4.0]\n"
     ]
    }
   ],
   "source": [
    "molecule = 'H .0 .0 -{0}; Li .0 .0 {0}'\n",
    "algorithms = ['VQE', 'ExactEigensolver']\n",
    "\n",
    "dr  = [x * 0.1  for x in range(6, 20)]\n",
    "dr += [x * 0.25 for x in range(8, 18)]\n",
    "dr += [4.0]\n",
    "energies = np.empty([len(algorithms), len(dr)])\n",
    "hf_energies = np.empty(len(dr))\n",
    "distances = np.empty(len(dr))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i, d in enumerate(dr):\n",
    "    for j in range(len(algorithms)):   \n",
    "        driver = PySCFDriver(molecule.format(d/2), basis='sto3g')\n",
    "        qmolecule = driver.run()\n",
    "        operator =  Hamiltonian(qubit_mapping=QubitMappingType.PARITY,\n",
    "                                two_qubit_reduction=True, freeze_core=True,\n",
    "                                orbital_reduction=[-3, -2])\n",
    "        qubit_op, aux_ops = operator.run(qmolecule)\n",
    "        if algorithms[j] == 'ExactEigensolver':\n",
    "            result = ExactEigensolver(qubit_op, aux_operators=aux_ops).run()\n",
    "        optimizer = COBYLA(maxiter=1000)\n",
    "        initial_state = HartreeFock(qubit_op.num_qubits,\n",
    "                                    operator.molecule_info['num_orbitals'],\n",
    "                                    operator.molecule_info['num_particles'],\n",
    "                                    qubit_mapping=operator._qubit_mapping,\n",
    "                                    two_qubit_reduction=operator._two_qubit_reduction)\n",
    "        \n",
    "        var_form = UCCSD(qubit_op.num_qubits, depth=1,\n",
    "                        num_orbitals=operator.molecule_info['num_orbitals'],\n",
    "                        num_particles=operator.molecule_info['num_particles'],\n",
    "                        initial_state=initial_state,\n",
    "                        qubit_mapping=operator._qubit_mapping,\n",
    "                        two_qubit_reduction=operator._two_qubit_reduction)\n",
    "        \n",
    "        algo = VQE(qubit_op, var_form, optimizer)\n",
    "        result = algo.run(QuantumInstance(BasicAer.get_backend('statevector_simulator')))\n",
    "            \n",
    "        lines, result = operator.process_algorithm_result(result)\n",
    "        energies[j][i] = result['energy']\n",
    "        hf_energies[i] = result['hf_energy']\n",
    "\n",
    "\n",
    "    distances[i] = d"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pylab.plot(distances, hf_energies, label='Hartree-Fock')\n",
    "for j in range(len(algorithm)):\n",
    "    pylab.plot(distances, energies[j], label=algorithms[j])\n",
    "pylab.xlabel('Interatomic distance')\n",
    "pylab.ylabel('Energy')\n",
    "pylab.title('LiH Ground State Energy')\n",
    "pylab.legend(loc='upper right');"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
